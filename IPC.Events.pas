unit IPC.Events;

interface

uses
  Winapi.Windows, System.SysUtils;

type
{$REGION 'Implementation details'}
  Detail = record type
    IEvent = interface
      function GetIsSignalled: boolean;

      procedure WaitFor(const Timeout: cardinal);
      procedure Signal;

      property IsSignalled: boolean read GetIsSignalled;
    end;

    TEventImpl = class(TInterfacedObject, IEvent)
    strict private
      FEventHandle: THandle;
    public
      constructor Create(const Name: string);
      destructor Destroy; override;

      procedure WaitFor(const Timeout: cardinal);
      procedure Signal;

      function GetIsSignalled: boolean;
    end;
  end;
{$ENDREGION}

  Event = record
  strict private
    FImpl: Detail.IEvent;
    function GetIsSignalled: boolean;
  private
    property Impl: Detail.IEvent read FImpl;
  public
    class function Create(const Name: string): Event; static;
    class operator Implicit(const Impl: Detail.IEvent): Event;

    procedure WaitForSignal(const TimeoutInMilliseconds: cardinal = INFINITE);
    procedure Signal;

    property IsSignalled: boolean read GetIsSignalled;
  end;


implementation

{ Detail.TEventImpl }

constructor Detail.TEventImpl.Create(const Name: string);
begin
  inherited Create;

  FEventHandle := CreateEvent(nil, False, False, PChar(Name));
  if (FEventHandle = 0) then
    RaiseLastOSError();
end;

destructor Detail.TEventImpl.Destroy;
begin
  CloseHandle(FEventHandle);

  inherited;
end;

function Detail.TEventImpl.GetIsSignalled: boolean;
var
  r: cardinal;
begin
  r := WaitForSingleObject(FEventHandle, 0);
  if (r = WAIT_FAILED) then
    RaiseLastOSError();

  result := (r = WAIT_OBJECT_0);
end;

procedure Detail.TEventImpl.Signal;
begin
  SetEvent(FEventHandle);
end;

procedure Detail.TEventImpl.WaitFor(const Timeout: cardinal);
var
  r: cardinal;
begin
  r := WaitForSingleObject(FEventHandle, Timeout);
  if (r = WAIT_FAILED) then
    RaiseLastOSError();
end;

{ Event }

class function Event.Create(const Name: string): Event;
begin
  result := Detail.TEventImpl.Create(Name);
end;

function Event.GetIsSignalled: boolean;
begin
  result := Impl.IsSignalled;
end;

class operator Event.Implicit(const Impl: Detail.IEvent): Event;
begin
  result.FImpl := Impl;
end;

procedure Event.Signal;
begin
  Impl.Signal;
end;

procedure Event.WaitForSignal(const TimeoutInMilliseconds: cardinal);
begin
  Impl.WaitFor(TimeoutInMilliseconds);
end;

end.
